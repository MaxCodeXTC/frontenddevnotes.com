<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" href="../css/reset.css" />
    <link rel="stylesheet" href="../css/styles.css" />
    <link rel="stylesheet" href="../css/prism.css" />
    <script src="../js/prism.js"></script>
    <title>Frontend Developer Notes: on Flow</title>
  </head>

  <body>
    <div id="menu">
      <h3>Notes on Flow & Static Type Checking for JavaScript</h3>
      <div id="from">from: <a href="/index.html">frontenddevnotes.com</a></div>
      <div id="toc"></div>
    </div>

    <div id="panel">
      <div id="menuButton">|||</div>

      <div id="bookPadding">
        <h1>
          Notes on Flow & Static Type Checking for JavaScript
        </h1>

        <h3 style="margin-top:0px">
          For Intermediate to Advanced JavaScript Developers
        </h3>
        <section>
          These notes discuss using the Flow type checker that can be bolted to
          JavaScript forcing it to act like a static programming language during
          development.
        </section>

        <hr />

        <div id="chapter1" class="chapter">
          <h2>1 : What is a JavaScript Type?</h2>

          <section class="sub">
            <p>
              This section briefly describes types in the context of JavaScript
              and through the lense of Flow.
            </p>
          </section>

          <h3>1.1 - JavaScript is Dynamically Typed</h3>

          <p>
            The JavaScript language is made up of data structures like
            <code>Boolean</code>, <code>Null</code>, <code>Undefined</code>,
            <code>String</code>, <code>Object</code>, etc... . When creating a
            named data structure (e.g. a variable, a function parameter, an
            object property) in JavaScript the language does not require that
            you define/annotate what type(s) of data structure will be
            reference/stored. In JavaScript you can create a parameter,
            variable, or object property and assign it any data structure you
            want and then re-assign it with a new data structure type in the
            future without an error resulting from the change in data structure.
          </p>

          <div class="notes">
            <p>
              <strong>Keep In Mind:</strong>
            </p>
            <ol>
              <li>
                The changing of data does not error. But, of course using the
                wrong type of data in the wrong way might cause a runtime error
                e.g. a string where only a number is expected,
                <code>"foo".toFixed(); // throws error</code>.
              </li>
            </ol>
          </div>

          <pre class="line-numbers"><code class="language-js noRun">
let myVariable = 1;    
// myVariable now references a value that is a number type data structure
// I did not tell JavaScript that myVariable would hold a number

console.log(typeof myVariable) // logs "number"

// JS dynamically, at runtime, figured out that the structure was a number and of the type number

myVariable = 'string';
// now, myVariable references a value that is a string type data structure

console.log(typeof myVariable) // logs "string"

myVariable = {};
// now, myVariable references a value that is an object type data structure

console.log(typeof myVariable) // logs "Object"

// The JavaScript runtime figures out data structure types dynamically the developer does 
// not tell the program what types before running the program

</code></pre>

          <p>
            Because JavaScript allows type changes at runtime (i.e. when running
            in a browser) it is considered a dynamically typed language.
          </p>

          <div class="notes">
            <p>
              <strong>Note:</strong>
            </p>
            <ol>
              <li>
                Dynamically typed languages stand in opposition to statically
                typed languages because static programming languages typically
                involve a compiliation step that fails if type invariants occur
                (i.e. a type changes or is used incorrectly). While dynamically
                typed languages that are not compiled only show type errors at
                runtime. And, if it is weakly typed it will to some degree try
                and avoid errors by doing hidden type conversions to avoid
                runtime errors.
              </li>
              <li>
                JavaScript is weakly typed in the sense that it will do implicit
                (i.e. hidden) value conversions (i.e. coercive) at runtime
                trying to avoid errors using a complex set of rules for
                conversions (e.g.
                <code>'3' * '2' === 6 // no error due to coercion</code>). As
                languages do less and less conversions/coercion they become more
                strongly typed but yet can still be dynamically typed languages
                (e.g. Ruby, Python, Lua, PHP etc...)
              </li>
            </ol>
          </div>

          <h3>1.2 - Making JavaScript Statically Typed (via Flow)</h3>

          <p>
            One should think of static language features and static type
            checkers (e.g. Flow) as a system in a programming language that
            forces invariants (i.e. invariants means the program fails unless
            all values have a type, inferred or explicitly defined, and that
            that type does not change and is used correctly at all times). Thus,
            a type checking system like Flow layers itself over the top of
            JavaScript introducing a compilation step where it attempts to treat
            JavaScript as a static programming language.
          </p>

          <p>
            Some developers believe that statically typed languages that have a
            compiling/transpiler step, which do type checking before runtime
            execution, are superior to dynamically typed languages that have no
            compiling/transpiler step. The reason being that type errors can be
            surfaced before running the code (e.g. with Javascript that would be
            before the browser executes/runs code meaning errors are surfaced
            before runtime).
          </p>

          <div class="notes">
            <p>
              <strong>Keep In Mind:</strong>
            </p>
            <ol>
              <li>
                To layer a type system over the top of JavaScript requires
                adding a transpiler step to your development workflow to remove
                the type annotations from the source code (i.e. types have to be
                removed for JavaScript to actually run). If you are using Babel
                then you have already accept this step and Flow can be used to
                remove Flow syntax from your source code as it is being built
                for production by Babel.
              </li>
            </ol>
          </div>

          <p>
            To initially grok Flow and static types in the context of JavaScript
            consider that by using Flow one can define/annotate (e.g.
            <code>:string</code> and <code>:number</code>) what type of value a
            variable or parameter can store/reference. Provide the wrong type of
            data in the wrong place and Flow will complain/error.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow 

let score:number;

score = '3'; // Error, the value must be a number not a string containing a number

function square(n: number) {
  return n * n;
}

square("2"); // Error, n can't be a string, just a number!

/* Flow command line tool or Flow running in your IDE will indicate the following errors:

3: score = '3'; // Error, the value must be a number
           ^ Cannot assign `'3'` to `score` because string [1] is incompatible with number [2].
References:
3: score = '3'; // Error, the value must be a number
           ^ [1]
1: let score:number;
             ^ [2]
9: square("2"); // Error, n can't be a string, just a number!
          ^ Cannot call `square` with `"2"` bound to `n` because string [1] is incompatible with number [2].
References:
9: square("2"); // Error, n can't be a string, just a number!
          ^ [1]
5: function square(n: number) {
                      ^ [2]
*/

</code></pre>

          <p>
            Note that most statically type languages and static type systems
            like Flow will also infer types from expressions without
            annotations.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow  

/* Flow is inferring that n in the function below should be a number not a string because it is pulling 
JavaScript from a weakly typed language to a strongly typed language trying 
to get it to error when ambiguity is introduced because of weakness in types or 
native coercion routines/rules. */

function square(n) {
  return n * n; // type error inferred because expression expects numbers not strings
  // Non-Flow JS would not error here, you'd get 4 
  // because native JavaScript try and do the correct thing
}

square("2");

/* Flow command line tool or Flow running in your IDE will indicate the following errors:

4:   return n * n; // type error inferred because expression expects numbers not strings
            ^ Cannot perform arithmetic operation because string [1] is not a number.
References:
7: square("2");
          ^ [1]
4:   return n * n; // type error inferred because expression expects numbers not strings
                ^ Cannot perform arithmetic operation because string [1] is not a number.
References:
7: square("2");
          ^ [1]
*/

</code></pre>

          <p>
            Additionally, a type checker like Flow is not only concerned with
            implicit type annotations for variables, parameters, and object
            properties but also values returned from functions.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

function square(n: number):string {
  return n * n; // Error, this returns a number not a string
}

square(2);

/* Flow command line tool or Flow running in your IDE will indicate the following errors:

4:   return n * n; // Error, this returns a number not a string
            ^ Cannot return `n * n` because number [1] is incompatible with string [2].
References:
4:   return n * n; // Error, this returns a number not a string
            ^ [1]
3: function square(n: number):string {
                              ^ [2]
*/
    </code></pre>
        </div>

        <div id="chapter2" class="chapter">
          <h2>2 : What exactly is Flow & do I need it?</h2>

          <section class="sub">
            <p>
              This will briefly explain the concept of Flow and the need for it.
            </p>
          </section>

          <h3>2.1 - What is Flow?</h3>

          <p>
            Flow is an open source JavaScript library written by Facebook that
            statically analysis your JavaScript files as if it was a static
            language instead of a dynamic langauge. It does this by inferring
            types and analysis type annotations written over the top of
            JavaScript from the developer (e.g.
            <code>let score: number</code>, score can only be assigned values
            that are JavaScript numbers. But this isn't valid JS so the
            <code>: number</code> has to be removed before a JS engine will
            run).
          </p>

          <p>
            Basically, it is a tool not unlike eslint that statically analyzes
            your code during development for invariant data type problems. It
            might be best to simply think of it as a linting tool that expects
            JavaScript syntax to conform to a typed system and when id does not,
            it errors/warns/blocks development, etc... .
          </p>

          <h3>2.2 - Do I need Flow?</h3>

          <p>
            No matter what anyone exposes about code quality, managing types
            does not mean you have to use static types and avoid dynamic types
            to have a maintainable code base. Flow usage is a reflection upon
            the subjective development whims of developers and their context
            (i.e. Not everyone has Facebook problems. Only facebook and their
            developers might have the problems that Flow fixes). It is likely
            the case that if you or your team requires the use of
            strict/strongly typed code,
            <strong>a bolted on type system</strong> will
            <a
              href="https://medium.com/javascript-scene/the-typescript-tax-132ff4cb175b"
              >bring more problems than solutions</a
            >. If types are an absolute requirement for your project consider
            using a natively type language (e.g. Reason, PureScript, Elm) before
            settling for Flow or TypeScript.
          </p>

          <div class="notes">
            <p>
              <strong>Keep In Mind:</strong>
            </p>
            <ol>
              <li>
                TypeScript, an alternative to Flow, is basically Flow + Babel in
                terms of static v.s. dynamically typed features. So Flow + Babel
                are not different from TypeScript in the context of type
                systems. Both at the end of the day bolt on a new non-native
                language features (i.e. a type system plus more e.g. Flow
                linting and much more in the case of TypeScript).
              </li>
            </ol>
          </div>

          <p>
            With that said, many individuals and teams find Flow (i.e. bolted on
            type systems) extremely helpful. But this is more telling of the
            individual or team and the problems and tradeoffs they wish to have
            and not exactly based on the objective merits of Flow (i.e. bolted
            on type systems) itself. Flows value is in the eye of the beholder.
            If you are trying to figure out if Flow should be used on a team,
            first asked if everyone on the teams agrees Flow is absolutely
            required given its costs. Be concerned about co-workers who take a
            neutral, naive, or negative perspective on Flow because the effort
            to make it valuable takes 100% commitment from everyone who writes
            code where Flow is used. Flow usage is the kind of choice that
            requires 100% participation/buy-in from all team members for its
            value to rise above its costs. If the team can't reach a massive
            majority agreement on the usage of Flow then Flow should likely be
            avoided because the subjective/contextual value is directly tied to
            the commitment level and to the quality of its implementation.
          </p>

          <div class="notes">
            <p>
              <strong>Keep in Mind:</strong>
            </p>
            <ol>
              <li>
                For Flow to reach a tipping point in value I think it has to be
                implemented on day one and the implementation has to be
                normalized, documented, and syntax standards/rules have to be
                followed consistently across all modules (massive developer
                buy-in and conformance is needed). If you adapt it after the
                fact or assume developers will just figure it out in terms of
                conventions as they go, you'll likely never get the value out of
                the cost (the syntax variations cause massive indirection in the
                code). All that you have done is added a massively complex
                syntax and cruft over the top of complications that already
                exist that will likely only evolve from one state of
                incompleteness to the next (i.e. we'll add it incrementally and
                we'll avoid having stop and fix hard problems today. Nope, those
                problems don't go away and likely never really get solved).
              </li>
            </ol>
          </div>

          <h3>2.3 - Flow Cons</h3>

          <ul>
            <li>
              In a lot of cases adding annotations to modules can double the
              line size of a module making them unnecessarily complex to read or
              change.
            </li>
            <li>
              Flow comes with an entire layer of management around type modules
              (both custom and third-party type modules).
            </li>
            <li>
              Type annotations and declarations (i.e. flow syntax) are custom
              cognitive overhead that clutters your source code with verbose
              non-native syntax CRUFT that as of today will never become native
              to the language.
            </li>
            <li>
              Typing out annotations and appeasing the Flow checker can be a
              massive time suck with little return to developers and overall
              code quality (Flow being the cause of removing a lot of important
              errors is a debated topic with no clear outcome).
            </li>
            <li>
              JavaScript developers who have never used Flow will experience a
              significant learning curve to work within a new code base. Which
              is not ideal, when already trying to learning a new code base.
              Thus, making the code base even more difficult to work in and can
              result in hiring and development difficulties.
            </li>
            <li>
              Your JavaScript source code is not valid JavaScript (
              <a href="https://flow.org/en/docs/types/comments/"
                >flow comment syntax is available</a
              >
              but not really used in practice).
            </li>
            <li>
              Flow fails at simplistically, and with little effort, at turning
              JavaScript into a statically typed language. The outcome for large
              complex code bases, after a couple of years in the wild, seems to
              be use a language where it is built in (i.e. Reason, Elm,
              PureScript) because the overhead is not worth the return.
            </li>
            <li>
              Flow is significantly a more complex type system and junk drawer
              of syntax than the one that comes with JavaScript. JavaScript
              already has a type system and one can learn it and use it in
              similar ways to manage types natively (KISS does more for
              maintainability and quality than endless configuration handcuffs
              and CRUFT).
            </li>
            <li>
              Flow solves unrealized problems that you might not ever have
              instead of actual problems you clearly have today. And if you do
              have some degree of the problems that it claims to solve, the
              problems are trivial compared to the cost of implementing and
              maintaining Flow.
            </li>
            <li>
              The case for type errors at runtime appears to be massively
              overstated. Does it happen yes. Is it manageable without a bolted
              on type system. Yes.
            </li>
            <li>
              Flow error messages can be jarring and cryptic when compared to
              error messages from languages where static types are baked into
              the language.
            </li>
            <li>
              The momentum/community around a type checker that is bolted on to
              JavaScript is not behind Flow it is firmly behind TypeScript. But
              both suffer from, historically, a losing proposition (i.e. bolting
              non-native languages changes to JS e.g. module systems)
            </li>
            <li>
              Type definitions, or lack of, for Third party libraries and tools
              can force the hand of a developer to make sacrifices in code
              quality.
            </li>
            <li>Flow has no powers at runtime.</li>
            <li>
              What to type and how to type values can become a very subjective
              and debated topic among teams members which requires management
              and standards (i.e. overhead that can slow you down more than the
              bugs that might occur without Flow or worse slowness because no
              management or standards are created and enforced at all, reeking
              pain and suffering for anyone who has to commit code).
            </li>
            <li>
              In theory, the value of Flow is wrapped up in this idea (type
              theory) that if all values are identified with a type(s) then one
              can prove how sound a program will be (not unlike logical proofs).
              The theory is good, however the implementations details wears at
              the theoretical. And the implementation is not simply convention
              alone (i.e. a hammer can be designed poorly regardless of if you
              use it correctly). The value of an unsound, bolted on, type system
              is not a given value. It is a debated topic with a long history of
              plus's and minus's hinging on context and implementation details.
            </li>
            <li>
              Learning Flow to be an expert can take 6 to 8 months (likely less)
              and this is if the developer views it as worth learning well. If
              the developer views it as an annoyance and a massive time suck
              with little to no return, learning it might go on indefinitely.
              Either way, if developers have never seen your code or used Flow
              you've added an entire sub-language/syntax to be learned before
              learning about the actual code. And the worse part is this is not
              an isolated syntax but one that muddies the waters of JavaScript
              syntax itself (a drop of poison in a glass of water). Meaning, if
              you are use to JavaScript syntax alone having the mental overhead
              of a bolted on syntax can take a long time to consciously and
              unconsciously jive with all ones previous mental models of the
              language. Flow alters/evolves JavaScript syntax and this wears on
              the native lense through which many JavaScript developers have
              view JavaScript for years.
            </li>
            <li>
              Not uncommon that Flow implementations (and it could be the
              implementation not Flow) turn into valueless overhead cycles that
              will slow production and give only a return of intangible and
              theoretical benefits. (i.e. developers prolong each code commit
              because they have to "rewrite their code to satisfy (or work
              around) the type system.")
            </li>
            <li>
              Unless one blocks production code on Flow errors most developers
              will ignore Flow because appeasing Flow can be a confusing and
              time consuming routine.
            </li>
          </ul>

          <h3>2.4 - Flow Pros</h3>

          <ul>
            <li>
              Values (e.g. variables, parameters, object properties, expression
              outcomes, etc...) have a more explicit and obvious type. Which
              some claim can lead to fewer runtime errors and fewer regressions
              when refactoring.
            </li>
            <li>Avoid cluttering unit tests with type checking routines.</li>
            <li>
              Avoid writing type related checks in function calls and the
              corresponding error throwing boilerplate if the type checks fail.
              Many argue that if you don't have to write a lot of defensive code
              dealing with types of value you not only simplify your code but
              make it more preferment.
            </li>
            <li>
              Possible that some JavaScript type coercion, resulting in runtime
              errors, can be avoided <code>before runtime</code> (i.e. earlier
              errors at compile time instead of run time).
            </li>
            <li>
              Some degree of inline documentation for functions and classes is
              provided by using Flow syntax (e.g. what parameter is expect to a
              function, and in what form, and what value should be returned).
            </li>
            <li>
              Can hint/inform when a refactor is incomplete or causes further
              regressions.
            </li>
            <li>
              Improvement to developer experience when using certain IDE's
              (autocomplete, inline documentation etc...)
            </li>
          </ul>
        </div>

        <div id="chapter3" class="chapter">
          <h2>3 : Overview of thinking in Flow?</h2>

          <section class="sub">
            <p>
              This will briefly discuss how Flow fits into most development
              routines.
            </p>
          </section>

          <h3>3.1 - Developing with Flow</h3>

          <p>
            Flow is a node command line tool that can analysis your JavaScript
            files for types in near real time. Most developers have Flow
            integrated into their IDE so that as they work in their code Flow is
            always checking and reporting on Flow errors in real time without
            having to monitor or use a command line interface (i.e. using a
            <a href="https://flow.org/en/docs/config/"
              ><code>.flowconfig</code> file</a
            >).
          </p>

          <p>
            The files that Flow checks can be designated file by file or one can
            configure Flow to check all files of X type in certain directories.
            Given that you can tell Flow exactly which files to check and which
            files not to check many consider Flow to be something you can
            gradually adopt.
          </p>

          <p>
            To designate the files you want Flow to monitor (assuming you have
            <a href="https://flow.org/en/docs/install/">installed</a> and are
            <a href="https://flow.org/en/docs/usage/">running</a> Flow), from
            within the files themselves, simply add the following comment to the
            top of the file:
          </p>

          <pre class="line-numbers"><code class="language-js noRun">// @flow



</code></pre>
          <p>or</p>
          <pre class="line-numbers"><code class="language-js noRun">/* @flow */



</code></pre>

          <h3>3.2 - Flow Type Inferences</h3>

          <p>
            Without adding any Flow type annotation syntax, and assuming a file
            has <code>// @flow</code> on the first line, Flow will infer types
            for all values in your file (Including imported values).
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow  

function square(n) {
  return n * n; // type error inferred because expression expects numbers not strings
}

square("2");

/* Flow command line tool or Flow running in your IDE will indicate the following errors:

4:   return n * n; // type error inferred because expression expects numbers not strings
            ^ Cannot perform arithmetic operation because string [1] is not a number.
References:
7: square("2");
          ^ [1]
4:   return n * n; // type error inferred because expression expects numbers not strings
                ^ Cannot perform arithmetic operation because string [1] is not a number.
References:
7: square("2");
          ^ [1]
*/
  </code></pre>

          <p>
            Note that without Flow annotations (i.e. inference alone), Flow will
            have too:
          </p>

          <p>
            <quote
              >"If Flow is unable to figure out what the exact type is for each
              value, Flow must figure out what every possible value is and check
              to make sure that the code around it will still work with all of
              the possible types." - Flow Docs</quote
            >
          </p>

          <p>
            Inference errors alone do not bring much value. The point of adding
            Flow to your code is so that you can annotate values with types
            (especially values like functions parameters, values returned from
            functions, Object property's, and Array values). Inferences from
            Flow is just a courtesy so you don't have to type everything, but
            Flow assumes that you are not only using Flow for inferences. Flow's
            value is tied up in using the annotating system it provides to
            explicitly track values (i.e. by using type annotations one can in a
            sense create logical proofs/formulas for all values so that it will
            be near impossible for type errors to occur at runtime.).
          </p>

          <h3>3.3 - What is a Flow Type Annotation?</h3>

          <p>
            Flow provides a syntax, pretty much an evolution of the JavaScript
            language, that it unfortunately calls "Types" (This can get
            confusing because it does not correlate exactly to native types in
            JavaScript). Flow type syntax/annotations are added to your
            JavaScript, which is used by Flow to statically lint/analysis your
            code in the context of a static type system (i.e. flow annotations
            layer over the top of JavaScript a custom sub-language syntax that
            is used by the Flow type checking system to analysis your JavaScript
            as if it were a statically typed language and strongly typed. This
            is not at all different from something like eslint that analysis
            your JS and tells you stuff about the code written).
          </p>

          <p>
            Flow offers the following type annotations (i.e. really an entire
            type syntax, including tools and utilities, for annotating values in
            JavaScript):
          </p>

          <p>
            <strong>Primitive Types</strong><br />
            <strong>Literal Types</strong><br />
            <strong>Mixed Types</strong><br />
            <strong>Any Types</strong><br />
            <strong>Maybe Types</strong><br />
            <strong>Function Types</strong><br />
            <strong>Object Types</strong><br />
            <strong>Array Types</strong><br />
            <strong>Tuple Types</strong><br />
            <strong>Class Types</strong><br />
            <strong>Type Aliases</strong><br />
            <strong>Opaque Type Aliases</strong><br />
            <strong>Interface Types</strong><br />
            <strong>Generic Types</strong><br />
            <strong>Union Types</strong><br />
            <strong>Intersection Types</strong><br />
            <strong>Type Casting Expressions</strong><br />
            <strong>Utility Types</strong><br />
            <strong>Module Types</strong><br />
          </p>

          <h3>3.4 - Flow Language Restrictions/Linting</h3>

          <p>
            As previously mentioned, Flow can infer types and can be told about
            types via annotations. But Flow can also restrict the language via
            an internal Flow linting system. For example it will lint/complain
            about passing unexpected arguments to a function.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow  

const myFunc = (x) =&gt; {
  return x;
}

myFunc(1,2);

/* Flow command line tool or Flow running in your IDE will indicate the following errors:

5: myFunc(1,2);
            ^ Cannot call `myFunc` because no more than 1 argument is expected by function [1].
References:
1: const myFunc = (x) =&gt; {                  ^ [1]

*/
</code></pre>

          <p>
            These types of errors slightly extend Flow past a type checking
            system and into the realm of JavaScript conventions/linting
            restrictions.
          </p>

          <h3>3.5 - What can be Annotated?</h3>

          <p>
            Any value or expression in JavaScript can be annotated. If you're
            new to Flow or static types this might not help you grok exactly how
            JavaScript is annotated with Flow types. It might initially be
            helpful to think about what can be annotated (or inferred) in terms
            of:
          </p>

          <p>
            <strong>Variable's:</strong><br />
            <strong>Function Parameter's:</strong><br />
            <strong>A Function's Return Value:</strong><br />
            <strong>Object's</strong><br />
            <strong>Array's</strong><br />
            <strong>Class's</strong><br />
            <strong>Expressions</strong><br />
          </p>

          <p>
            Below each of the above typing situations are simplistically and
            briefly explored in order to initially reveal some insight into what
            can be typed (most of the examples use very simple Flow type
            annotations e.g. primitive types <code>:string</code> and
            <code>:number</code>):
          </p>

          <p><strong>Variable's:</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that this variable can only hold a 
// string or undefined using primitive type annotations

let myVariable: string | undefined = undefined;

</code></pre>

          <p><strong>Function Parameter's:</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that parameter a and b can only hold a 
// string using primitive type annotations

function concat(a: string, b: string){
  return a + b;
}

</code></pre>

          <p><strong>A Function's Return Value:</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that this function can only return a
// string using primitive type annotations

function concat(a, b):string {
  return a + b;
}

</code></pre>

          <p><strong>Object's</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that myObject must be an object and must have a name property 
// and the value must be a string using primitive type annotations

var myObject: {| name: string |} = { name: 'pat' };

</code></pre>

          <p><strong>Array's</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that myArray must be an array and can only contain 
// number values using primitive type annotations

let arr: Array&lt;number&gt; = [1, 2, 3];

</code></pre>

          <p><strong>Class's</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that myClassInstance must follow the types defined in TheClass

class TheClass { 
  score:number = 0
  noScoreMessage:string = 'No Score'
}

let myClassInstance: TheClass = new TheClass();

</code></pre>

          <p><strong>Expression's</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that the expression 2+2 must result in a number value

(2 + 2: number);

</code></pre>

          <div class="notes">
            <p>
              <strong>Keep In Mind:</strong>
            </p>
            <ol>
              <li>
                Anything you don't annotate will get inferred by Flow (i.e. Flow
                will deduct what the type is based on how it is used or what
                data structures get assigned). Unless you pull the escape hatch
                and tell flow to act like regular JS with the
                <code>:any</code> annotation.
              </li>
            </ol>
          </div>
        </div>

        <div id="chapter4" class="chapter">
          <h2>4 : Basic Flow Type Annotations</h2>

          <section class="sub">
            <p>
              This section outlines basic Flow type annotation syntax. Primitive
              Types, Function Types, Object Types, Array Types, Class Types,
              Literal Types, Maybe Types, Any Type, Mixed Type.
            </p>
          </section>

          <h3>4.1 - JavaScript Type Types</h3>

          <p>
            Flow offers the following baseline annotations for the common
            JavaScript data type structures which I call group together and call
            type type annotations (i.e. these baseline types have almost a one
            to one relationship with native JavaScript values):
          </p>

          <p>
            Primitive Types<br />
            Function Types<br />
            Object Types<br />
            Array Types<br />
            Class Types<br />
          </p>

          <p><strong>Primitive Types:</strong></p>

          <p>
            A JavaScript value (e.g. variables, parameters, values returned from
            functions, Object properties, Array items etc...) can be annotated
            as a primitive value using of the following flow type annotations:
          </p>

          <ul>
            <li><code>: boolean</code></li>
            <li><code>: number</code></li>
            <li><code>: string</code></li>
            <li><code>: null</code></li>
            <li>
              <code>: void</code> (<strong>Note:</strong> void is used to mean
              <code>undefined</code>)
            </li>
          </ul>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

let opened : boolean = false;
let score : number = 0;
let middleName : string = 'leroy';
const constantNull : null = null;
const constantUndefined : void = undefined; // Note void is used for undefined

</code></pre>

          <p><strong>Function Types:</strong></p>

          <p>
            A JavaScript function value can be annotated as a function type
            using one of the following flow type annotations:
          </p>

          <ul>
            <li><code>: () =&gt; void</code></li>
            <li>
              <code>: Function</code> (<code>Note:</code> Don't use this, be
              aware however you might see its use. Instead use
              <code>any</code> or
              <code>(...args: Array&lt;any&gt;) =&gt; any)</code>
            </li>
          </ul>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// myFunc has to be a function that returns a string

let myFunc : (num : number) =&gt; string;

myFunc = (num) =&gt; {
return num.toString();
};

myFunc(34241312);

</code></pre>

          <p>Can also be written (But really ugly and hard to read):</p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

let myFunc : (num : number) =&gt; string = (num) =&gt; {
  return num.toString();
};

myFunc(34241312);

</code></pre>

          <div class="notes">
            <p>
              <strong>Note:</strong>
            </p>
            <ol>
              <li>
                Using the <code>?</code> character you can tell the flow checker
                that a function parameter is optional. For example,
                <code>let myFunction(myParam?:string){...}</code> tells Flow
                that this function may or may not have a
                <code>myParam</code> parameter. You might wonder what is the
                different between
                <code>let myFunction(myParam?:string){...}</code> and
                <code>let myFunction(myParam:?string){...}</code> where a Maybe
                type is used. The difference is that a Maybe type will allow
                <code>null</code> while an optional function parameter will not
                allow <code>null</code>.
              </li>
            </ol>
          </div>

          <p><strong>Object Types:</strong></p>

          <p>
            A JavaScript value (e.g. Object properties) can be annotated as an
            Object type using the following flow type annotations (Note the
            properties in the Object can be typed too):
          </p>

          <ul>
            <li><code>: { [key: string]: any}</code> or <code>Object</code></li>
            <li><code>: {}</code></li>
          </ul>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

let myObj1:Object = {}; // uses : Object but this is going to be deprecated

myObj1.prop = 'prop';

// Should use : { [key: string]: any} instead of : Object

let myObj2:{[key:string]:string} = {}; // uses : { [key: string]: string}

myObj2.prop = 'prop';
  
</code></pre>

          <p>
            Arbitrary objects that you don't set properties on can be annotated
            like (helpful when annotating parameters):
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

const arbitraryObject = {prop:'prop'};

let myObject:{} = arbitraryObject; // uses : {}

// or as parameter

function objectToString(obj: {}) {
  return obj.toString()
}

objectToString(arbitraryObject);
    
</code></pre>

          <div class="notes">
            <p>
              <strong>Note:</strong>
            </p>
            <ol>
              <li>
                Using the <code>?</code> character you can tell the flow checker
                that an object might have a property or it might not. For
                example, <code>let myObject : {score?:number} = {}</code> tells
                Flow that this object may or may not have a score property with
                a number value.
              </li>
              <li>
                Using the <code>|</code> character Flow can be informed when an
                object must contain a specific property. For example,
                <code>let myObject : {|score:number|} = {score:120}</code>
                tells Flow that this object must have a score property with a
                number value.
              </li>
            </ol>
          </div>

          <p><strong>Array Types:</strong></p>

          <p>
            A JavaScript value can be annotated as an Array type using the
            following flow type annotations (Note that the items in the Array
            can be typed too):
          </p>

          <ul>
            <li><code>: Array&lt;any&gt;</code></li>
            <li><code>: $ReadOnlyArray&lt;any&gt;</code></li>
          </ul>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow
  
let myArray: Array&lt;number&gt; = [1, 2, 3];; 
// a shorthand is available to the above syntax
// let myArray: number[];  

// possible to have Flow make sure certain Arrays are read only
const readonlyArray: $ReadOnlyArray&lt;number&gt; = [1, 2, 3];
      
  </code></pre>

          <p><strong>Class Types:</strong></p>

          <p>
            To annotate a Class instance, where ever you create an instance of
            the class, annotate the instance with the class name (assuming
            annotations have been added to the Class definition) .
          </p>

          <ul>
            <li><code>: TheClassName</code></li>
          </ul>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that myClassInstance must follow the types defined in TheClass

class TheClass { // using https://tc39.es/proposal-class-public-fields/
  score:number = 0
  noScoreMessage:string = 'No Score'
}

let myClassInstance: TheClass = new TheClass();
  
  </code></pre>

          <h3>
            4.2 - Exact Primitive (aka Literal) Type Values)
          </h3>

          <p>
            Flow offers the <strong>Literal Type</strong> (e.g.
            <code>const noPoints:0 = 0; </code>) so a data structure can be
            fixed to an exact primitive value or set of primitive values. The
            primtive values that can be used are <code>true</code>,
            <code>false</code>, <code>null</code>, <code>undefined</code>, any
            string (e.g. <code>'foo'</code>), or any number (e.g.
            <code>1432</code>).
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow
function getColorBasedOnMessageType(name: "success" | "warning" | "danger"):string {
switch (name) {
case "success" : return "green";
case "warning" : return "yellow";
case "danger"  : return "red";
}
}

/*
Notice how the | character was used to provide an
exact set of string values
/*

getColor("success"); 
getColor("danger");  
getColor("error");   // Error, can only be "success" | "warning" | "danger"

</code></pre>

          <p>
            Note that when using <code>const</code> a literal value is inferred.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
const foo = 'bar';

// same as const foo:bar = 'bar';
  </code></pre>

          <h3>
            4.3 - May or May not Exist Type Values (i.e.
            <code>: ?[TYPE HERE]</code>)
          </h3>

          <p>
            Flow offers the <strong>Maybe Type</strong> (e.g.
            <code>let score: ?number</code>) that can be combined with any other
            type to signify that the type is optional and if it does not exist
            then that is ok (i.e. it is ok that <code>null</code> or
            <code>undefined</code> was used here).
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

function acceptsMaybeNumber(value: ?number) {
  // ...
}

acceptsMaybeNumber(42);        
acceptsMaybeNumber();          
acceptsMaybeNumber(undefined); 
acceptsMaybeNumber(null);      
acceptsMaybeNumber("42");      // Error, can only be a number, undefined, or null

</code></pre>
          <h3>4.4 - Opt out of Flow Type (i.e. <code>: any</code>)</h3>

          <p>
            Flow offers the <strong>Any Type</strong> (e.g. <code>: any</code>)
            annotation to basically opt out of using the type checker.
            Essentially by using <code>: any</code> you side step the checker
            and allow JavaScript to do its normal thing in terms of type
            coercion and error'ing.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

function add(one: any, two: any): number {
return one + two;
}

add(1, 2);     // no flow error.
add("1", "2"); // no flow error.
add({}, []);   // no flow error.

</code></pre>
          <h3>4.5 - Unknown Type (i.e. <code>: mixed</code>)</h3>

          <p>
            Flow offers the <strong>Unknown Type</strong> (i.e.
            <code>: mixed</code>) so that any data structure can be provided.
            Note that if you use the mixed type then additional checks (e.g.
            <code>if</code> statement) have to exist that will determine its
            type or Flow will complain (as opposed to <code>:any</code> which
            won't complain about anything)
          </p>

          <p>This fails the Flow checker:</p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

function stringify(value: mixed) {
// $ExpectError
return "" + value; // Error!
}

stringify("foo");

/*
3:     return "" + value; // Error!
        ^ Cannot add empty string and `value` because mixed [1] could either behave like a string or like a number.
References:
1:   function stringify(value: mixed) {
                    ^ [1]
*/

</code></pre>

          <p>But this does not:</p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

function stringify(value: mixed) {
if (typeof value === 'string') {
return "" + value; // Works!
} else {
return "";
}
}

stringify("foo");

// no flow error.

</code></pre>
        </div>

        <div id="chapter5" class="chapter">
          <h2>5 : Not Basic Flow Type Annotations</h2>

          <section class="sub">
            <p>
              This section outlines how to organize and separate Flow types from
              JavaScript code
            </p>
          </section>

          <h3>5.1 - Tuple Types</h3>

          <h3>5.2 - Union Types</h3>

          <h3>5.3 - Intersection Types</h3>

          <h3>5.4 - Generic Types</h3>
        </div>

        <div id="chapter6" class="chapter">
          <h2>6 : Organizing Types</h2>

          <section class="sub">
            <p>
              This section outlines how to organize and separate Flow types from
              JavaScript code
            </p>
          </section>

          <h3>6.2 - Type Aliases</h3>

          <p>
            Flow annotations do not have to be written inline. It is possible
            using the Flow <code>type</code> syntax to create an aliase to flow
            annotations. This makes re-use and separation of concerns possible.
          </p>

          <p>
            For example syntax heavy inline type definitions like this function
            type (i.e. inline type noise and difficult to read):
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

let myFunc : (num : number) =&gt; string = (num) =&gt; {
  return num.toString();
};

let myOtherFunc : (num : number) =&gt; string = (num) =&gt; {
  return num.toString();
};

myFunc(34241312);
myOtherFunc(34241312);

</code></pre>

          <p>
            Can be visually simplified, concerns separated, and made re-usable
            using typed aliases.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// myFuncFlowAlias 
type myFuncFlowAlias = (num : number) =&gt; string;

// this function takes a number and returns a string 
let myFunc : myFuncFlowAlias = (num) =&gt; {
  return num.toString();
};

// this function takes a number and returns a string
let myOtherFunc : myFuncFlowAlias = (num) =&gt; {
  return num.toString();
};

myFunc(34241312);
myOtherFunc(34241312);
    
    </code></pre>

          <p>
            Flow Type aliases can be used anywhere a type annotation can be
            used.
          </p>

          <div class="notes">
            <p>
              <strong>Note:</strong>
            </p>
            <ol>
              <li>
                In my opinion all types should be aliased, removing as much
                noise from actual JavaScript as possible. Shared types should be
                imported into modules and local types should be organized below
                module imports.
              </li>
              <li>
                All aliases should end with the same identifier "FA" or
                "FlowAlias".
              </li>
            </ol>
          </div>

          <h3>6.2 - Importing/Exporting Type Aliases</h3>

          <p>
            In Flow, you can export type aliases, interfaces, and classes from
            one file and import them into another file.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">

// @flow
export default class Foo {};
export type MyObject = { /* ... */ };
export interface MyInterface { /* ... */ };

</code></pre>

          <p>Import:</p>

          <pre class="line-numbers"><code class="language-js noRun">

// @flow
import type Foo, {MyObject, MyInterface} from './exports';

</code></pre>
        </div>

        <div id="chapter7" class="chapter">
          <h2>References</h2>

          <section class="sub">
            <p>
              These external resources have been used in the creation of these
              notes.
            </p>
          </section>
          <ul>
            <li>
              <a href="https://youtu.be/Eti6_bSRgHU"
                >"Flow - Am I Your Type?" by Mark Volkmann</a
              >
            </li>
            <li>
              <a href="https://www.youtube.com/watch?v=MuC8I1JBKv0"
                >"The design of JavaScript type systems" by Dimitris
                Vardoulakis</a
              >
            </li>
            <li>
              <a href="https://youtu.be/lk8o7ym29WM"
                >Flow Typing a React Codebase - Forbes Lindesay</a
              >
            </li>
            <li>
              <a href="https://youtu.be/V1po0BT7kacs"
                >Jared Forsyth - Type Systems Will Make You a Better JavaScript
                Developer - React Conf 2017</a
              >
            </li>
            <li>
              <a
                href="https://www.freecodecamp.org/news/why-use-static-types-in-javascript-part-1-8382da1e0adb/"
                >Why use static types in JavaScript? (A 4-part primer on static
                typing with Flow)</a
              >
            </li>
            <li><a href="https://flow.org/en/docs/">Flow Docs</a></li>
            <li>
              <a href="https://www.manning.com/books/programming-with-types"
                >Programming with Types Examples in TypeScript</a
              >
            </li>
            <li>
              <a
                href="https://medium.com/javascript-scene/the-typescript-tax-132ff4cb175b"
                >The TypeScript Tax</a
              >
            </li>
            <li>
              <a href="https://frontendmasters.com/courses/typescript-v2/"
                >TypeScript 3 Fundamentals, v2</a
              >
            </li>
            <li>
              <a
                href="https://app.pluralsight.com/library/courses/flowtype-fundamentals/table-of-contents"
                >Flowtype Fundamentals</a
              >
            </li>
          </ul>
        </div>
      </div>
    </div>

    <script src="../js/slideout.min.js "></script>
    <script src="../js/jquery-3.3.1.slim.min.js "></script>

    <script>
      // Create slide out TOC
      var slideout = new Slideout({
        panel: document.getElementById("panel"),
        menu: document.getElementById("menu"),
        padding: 356,
        tolerance: 70
      });

      // Create TOC dynamically from content
      jQuery(".chapter").each(function(index) {
        jQuery("h2", "#chapter" + (index + 1)).each(function(i) {
          $(this).attr("id", index + 1);
          $("#toc").append(
            '<h5><a href="#' + (index + 1) + '">' + $(this).html() + "</a></h5>"
          );
        });

        jQuery("h3", "#chapter" + (index + 1)).each(function(i) {
          $(this).attr("id", index + 1 + "." + (i + 1));
          $("#toc").append(
            '<h6><a href="#' +
              (index + 1) +
              "." +
              (i + 1) +
              '">' +
              $(this).html() +
              "</a></h6>"
          );
        });
      });

      jQuery("#panel").on(
        "click",
        "a:not(.codesandboxlink a, .toolbar a)",
        function() {
          window.open($(this).attr("href"));
          return false;
        }
      );

      // create link to codesandob
      jQuery(".line-numbers:has(.language-js)")
        .not(":has(.noRun)")
        .before(
          '<div class="codesandboxlink"><a href="#">run/edit in codesandbox.io</a></div>'
        );

      // create event handler for codesandbox link
      jQuery("#panel").on("click", ".codesandboxlink a", function(e) {
        const code = $(this)
          .parent()
          .next(".code-toolbar:has(.language-js)")
          .find("code")
          .text();
        var newWindow = window.open("", "_blank");
        fetch("https://codesandbox.io/api/v1/sandboxes/define?json=1", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Accept: "application/json"
          },
          body: JSON.stringify({
            files: {
              "index.js": {
                content: code
              },
              "index.html": {
                content:
                  '<script src="./node_modules/babel-polyfill/dist/polyfill.js"><\/script><script src="https://unpkg.com/core-js-bundle@3.0.0-beta.3/index.js"><\/script><script src="index.js"><\/script>'
              },
              ".babelrc": {
                content: {
                  presets: ["env", "stage-0"]
                }
              },
              "package.json": {
                content: {
                  name: "ES2015+ Enlightenment Code Example",
                  version: "1.0.0",
                  description: "Simple Parcel/Babel Sandbox",
                  main: "index.html",
                  scripts: {
                    start: "parcel index.html --open",
                    build: "parcel build index.html"
                  },
                  dependencies: { "babel-polyfill": "6.26.0" },
                  devDependencies: {
                    "parcel-bundler": "^1.12.3",
                    "babel-preset-env": "^1.7.0",
                    "babel-preset-stage-0": "^6.24.1"
                  }
                }
              }
            }
          })
        })
          .then(x => x.json())
          .then(data => {
            newWindow.location.href =
              "https://codesandbox.io/embed/" +
              data.sandbox_id +
              "?forcerefresh=1&eslint=1&expanddevtools=1&hidenavigation=1&module=%2Findex.js";
          });
        e.preventDefault();
      });

      // toggle TOC from hamburger icon
      document
        .querySelector("#menuButton")
        .addEventListener("click", function() {
          slideout.toggle();
        });

      // toggle TOC on window resize
      window.addEventListener("resize", resizeThrottler, false);
      var resizeTimeout;
      function resizeThrottler() {
        // ignore resize events as long as an actualResizeHandler execution is in the queue
        if (!resizeTimeout) {
          resizeTimeout = setTimeout(function() {
            resizeTimeout = null;
            actualResizeHandler();

            // The actualResizeHandler will execute at a rate of 15fps
          }, 66);
        }
      }
      function actualResizeHandler() {
        if (window.innerWidth > 1036) {
          slideout.open();
        } else {
          slideout.close();
        }
      }

      // open TOC on load if window is wide enough
      window.addEventListener("load", function(event) {
        if (window.innerWidth > 1036) {
          slideout.open();
        } else {
          slideout.close();
        }
      });
    </script>
  </body>
</html>
