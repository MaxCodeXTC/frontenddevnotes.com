<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" href="../css/reset.css" />
    <link rel="stylesheet" href="../css/styles.css" />
    <link rel="stylesheet" href="../css/prism.css" />
    <script src="../js/prism.js"></script>
    <title>Frontend Developer Notes: on Flow</title>
  </head>

  <body>
    <div id="menu">
      <h3>Notes on Flow & Static Type Checking for JavaScript</h3>
      <div id="from">from: <a href="/index.html">frontenddevnotes.com</a></div>
      <div id="toc"></div>
    </div>

    <div id="panel">
      <div id="menuButton">|||</div>

      <div id="bookPadding">
        <h1>
          Notes on Flow & Static Type Checking for JavaScript
        </h1>

        <h3 style="margin-top:0px">For Intermediate JavaScript Developers</h3>
        <section>
          These notes discuss using the Flow type checker that can be bolted to
          JavaScript forcing it to act like a static programming language during
          development.
        </section>

        <hr />

        <div id="chapter1" class="chapter">
          <h2>1 : What is a JavaScript Type?</h2>

          <section class="sub">
            <p>
              This section briefly describe types in the context of JavaScript
              and through the lense of Flow.
            </p>
          </section>

          <h3>1.1 - JavaScript is Dynamically Typed</h3>

          <p>
            The JavaScript language is made up of data structures like
            <code>Boolean</code>, <code>Null</code>, <code>Undefined</code>,
            <code>String</code>, <code>Object</code>, etc... . When creating a
            named data structure (e.g. a variable, a function parameter, an
            object property) in JavaScript the language does not require that
            you define/annotate what type(s) of data structure will be
            reference/stored. In JavaScript you can create a parameter,
            variable, or object property and assign it any data structure you
            want and then re-assign it with a new data structure type in the
            future without an error resulting from the change in data structure.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
let myVariable = 1;    
// myVariable now references a value that is a number type data structure
// I did not tell JavaScript that myVariable would hold a number

console.log(typeof myVariable) // logs "number"

// It dynamically figured out that the structure was a number and of the type number

myVariable = 'string';
// now, myVariable references a value that is a string type data structure

console.log(typeof myVariable) // logs "string"

myVariable = {};
// now, myVariable references a value that is an object type data structure

console.log(typeof myVariable) // logs "Object"

// The JavaScript runtime figures out data structure types dynamically the developer does 
// not tell the program what types are required for the program to run

</code></pre>

          <p>
            Because JavaScript allows type changes at runtime (i.e. when running
            in a browser) it is considered a dynamically typed language.
          </p>

          <div class="notes">
            <p>
              <strong>Note:</strong>
            </p>
            <ol>
              <li>
                Dynamically typed languages stand in opposition to statically
                typed languages because static programming languages typically
                involve a compiliation step that fails if type invariants occur
                (i.e. a type changes or is used incorrectly).
              </li>
              <li>
                JavaScript is weakly typed in the sense that it will do implicit
                (i.e. hidden) value conversions (i.e. coercive) at runtime
                trying to avoid errors using a complex set of rules for
                conversions (e.g.
                <code>'3' * '2' === 6 // no error due to coercion</code>). As
                languages do less and less conversions/coercion they become more
                strongly typed but yet can still be dynamically typed languages
                (e.g. Ruby, Python, Lua, PHP etc...)
              </li>
            </ol>
          </div>

          <h3>1.2 - Making JavaScript Statically Typed (via Flow)</h3>

          <p>
            Some developers believe statically typed languages, which do type
            checking when compiling and before execution, are superior to
            dynamically typed languages (i.e. coercion + weak typing). The
            reason being that type errors can be surfaced before running the
            code (e.g. with Javascript that would be before the browser
            executes/runs code).
          </p>
          <p>
            One should think of static language features and static type
            checkers (e.g. Flow) as a system in a programming language that
            forces invariants (i.e. invariants means the program fails unless
            all values have a type, inferred or explicitly defined, and that
            that type does not change and is used correctly at all times). Thus,
            a type checking system like Flow layers itself over the top of
            JavaScript introducing a compilation step where it attempts to treat
            JavaScript as a static programming language.
          </p>
          <div class="notes">
            <p>
              <strong>Keep In Mind:</strong>
            </p>
            <ol>
              <li>
                To layer a type system over the top of JavaScript requires
                adding a transpiler step to your development workflow to remove
                the type annotations from the source code. If you are using
                Babel then you have already accept this step and Flow can be
                used to remove Flow syntax from your source code as it is being
                built for production by Babel.
              </li>
            </ol>
          </div>

          <p>
            To understand static types in the context of JavaScript consider
            that by using Flow one can define/annotate (e.g.
            <code>:string</code> and <code>:number</code>) what type of value a
            variable or parameter can store/reference. Provide the wrong type of
            data in the wrong place and Flow will complain.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow 

let score:number;

score = '3'; // Error, the value must be a number not a string containing a number

function square(n: number) {
  return n * n;
}

square("2"); // Error, n can't be a string, just a number!

/* Flow command line tool or Flow running in your IDE will indicate the following errors:

3: score = '3'; // Error, the value must be a number
           ^ Cannot assign `'3'` to `score` because string [1] is incompatible with number [2].
References:
3: score = '3'; // Error, the value must be a number
           ^ [1]
1: let score:number;
             ^ [2]
9: square("2"); // Error, n can't be a string, just a number!
          ^ Cannot call `square` with `"2"` bound to `n` because string [1] is incompatible with number [2].
References:
9: square("2"); // Error, n can't be a string, just a number!
          ^ [1]
5: function square(n: number) {
                      ^ [2]
*/

</code></pre>

          <p>
            Note that most statically type languages and static type systems
            like Flow will also infer types from expressions without
            annotations.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow  

function square(n) {
  return n * n; // type error inferred because expression expects numbers not strings
}

square("2");

/* Flow command line tool or Flow running in your IDE will indicate the following errors:

4:   return n * n; // type error inferred because expression expects numbers not strings
            ^ Cannot perform arithmetic operation because string [1] is not a number.
References:
7: square("2");
          ^ [1]
4:   return n * n; // type error inferred because expression expects numbers not strings
                ^ Cannot perform arithmetic operation because string [1] is not a number.
References:
7: square("2");
          ^ [1]
*/

</code></pre>

          <p>
            Additionally, a type checker like Flow is not only concerned with
            implicit type annotations for variables, parameters, and object
            properties but also values returned from functions.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

function square(n: number):string {
  return n * n; // Error, this returns a number not a string
}

square(2);

/* Flow command line tool or Flow running in your IDE will indicate the following errors:

4:   return n * n; // Error, this returns a number not a string
            ^ Cannot return `n * n` because number [1] is incompatible with string [2].
References:
4:   return n * n; // Error, this returns a number not a string
            ^ [1]
3: function square(n: number):string {
                              ^ [2]
*/
    </code></pre>
        </div>

        <div id="chapter2" class="chapter">
          <h2>2 : What exactly is Flow & do I need it?</h2>

          <section class="sub">
            <p>
              This will briefly explain the concept of Flow and the need for it.
            </p>
          </section>

          <h3>2.1 - What is Flow?</h3>

          <p>
            Flow is an open source JavaScript library written by Facebook that
            statically analysis your JavaScript files as if it was a static
            language. It does this by inferring types and from the developer
            annotating JavaScript values with type declarations (e.g.
            <code>let score: number</code>, score can only be assigned values
            that are JavaScript numbers).
          </p>

          <p>
            Basically, it is a tool not unlike eslint that statically analyzes
            your code during development for invariant data type problems. It
            might be best to simply think of it as a custom layer over the top
            of JavaScript that transforms the language into a statically typed
            language.
          </p>

          <h3>2.2 - Do I need Flow?</h3>

          <p>
            No matter what anyone exposes about code quality, managing types
            does not mean you have to use static types and avoid dynamic types
            to have a maintainable code base. Flow usage is a reflection upon
            the subjective development whims of developers and their context
            (i.e. Not everyone has Facebook problems. Only facebook and their
            developers might have the problems that Flow fixes). It is likely
            the case that if you or your team requires the use of
            strict/strongly typed code,
            <strong>a bolted on type system</strong> will bring more problems
            than solutions. If types are an absolute requirement for your
            project consider using a natively type language (e.g. Reason,
            PureScript, Elm) before settling for Flow.
          </p>

          <div class="notes">
            <p>
              <strong>Keep In Mind:</strong>
            </p>
            <ol>
              <li>
                TypeScript is basically Flow + Babel in terms of static v.s.
                dynamically typed features. So IMO Flow + Babel are not
                different from TypeScript. Both at the end of the day bolt on a
                new non-native language feature (i.e. a type system).
              </li>
            </ol>
          </div>

          <p>
            With that said, many individuals and teams find Flow extremely
            helpful. But this is more telling of the individual or team and the
            problems and pains they wish to have and not exactly based on the
            objective merits of Flow itself. Flows value is in the eye of the
            beholder. If you are trying to figure out if Flow should be used on
            a team, first asked if everyone on the teams agrees Flow is
            absolutely required. Be concerned about co-workers who take a
            neutral, naive, or negative perspective on Flow because the effort
            to make it valuable takes 100% commitment from everyone who writes
            code where Flow is used. Flow usage is the kind of choice that
            requires 100% participation from all team members for its value to
            rise above its costs. If the team can't reach 100% agreement on the
            usage of Flow then Flow should likely be avoided because the
            subjective/contextual value is directly tied to a 100% committed to
            the quality of its implementation (i.e. 1% to 99% Flow is worse than
            0% Flow. Going all in is the only way to think about Flow as the
            goal should be 100% Flow coverage. If you can't reach that when
            implementing it be leery of the costs of attempting anything shy of
            100%. Especially if you already have a large complex code base).
          </p>

          <div class="notes">
            <p>
              <strong>Note:</strong>
            </p>
            <ol>
              <li>
                Don't be tempted by the notion of the gradual adoption of Flow
                into a complex code base. If Flow is going to be worth the
                overhead it is best to start a project using it from the get go
                with very clear standards around how all values will be typed
                (even third party modules). Adopting Flow incrementally after
                that fact can be a very risky proposition (in terms of value and
                time spent).
              </li>
            </ol>
          </div>

          <h3>2.3 - Flow Cons</h3>

          <ul>
            <li>
              In a lot of cases adding annotations to modules can double the
              line size of a module making them unnecessarily complex to read or
              change.
            </li>
            <li>
              Flow comes with an entire layer of management around type modules
              (both custom and third-party type modules).
            </li>
            <li>
              Type annotations and declarations (i.e. flow syntax) are custom
              cognitive overhead that clutters your source code with verbose
              non-native syntax CRUFT that as of today will never become native
              to the language.
            </li>
            <li>
              Typing out annotations and appeasing the Flow checker can be a
              massive time suck with little return to developers and overall
              code quality.
            </li>
            <li>
              JavaScript developers who have never used Flow will experience a
              significant learning curve to work within a new code base. Which
              is not ideal, when already trying to learning a new code base.
              Thus, making the code base even more difficult to work in and can
              result in hiring and development difficulties.
            </li>
            <li>
              Your JavaScript source code is not valid JavaScript (
              <a href="https://flow.org/en/docs/types/comments/"
                >flow comment syntax is available</a
              >
              but not really used in practice).
            </li>
            <li>
              Flow fails at simplistically, and with little effort, at turning
              JavaScript into a statically typed language. The outcome for large
              complex code bases, after a couple of years in the wild, seems to
              be use a language where it is built in (i.e. Reason, Elm,
              PureScript) because the overhead is not worth the return.
            </li>
            <li>
              Flow is significantly a more complex type system and junk drawer
              of syntax than the one that comes with JavaScript. JavaScript
              already has a type system and one can learn it and use it in
              similar ways to manage types natively (KISS does more for
              maintainability and quality than endless configuration handcuffs
              and CRUFT).
            </li>
            <li>
              Flow solves unrealized problems that you might not ever have
              instead of actual problems you clearly have today. And if you do
              have some degree of the problems that it claims to solve, the
              problems are trivial compared to the cost of implementing and
              maintaining Flow.
            </li>
            <li>
              The case for type errors at runtime appears to be massively
              overstated. Does it happen yes. Is it manageable without a bolted
              on type system. Yes.
            </li>
            <li>
              Flow error messages can be jarring and cryptic when compared to
              error messages from languages where static types are baked into
              the language.
            </li>
            <li>
              The momentum/community around a type checker that is bolted on to
              JavaScript is not behind Flow it is firmly behind TypeScript. But
              both suffer from, historically, a losing proposition (i.e. bolting
              non-native languages changes to JS e.g. module systems)
            </li>
            <li>
              Type definitions, or lack of, for Third party libraries and tools
              can force the hand of a developer to make sacrifices in code
              quality.
            </li>
            <li>Flow has no powers at runtime.</li>
            <li>
              What to type and how to type values can become a very subjective
              and debated topic among teams members which requires management
              and standards (i.e. overhead that can slow you down more than the
              bugs that might occur without Flow or worse slowness because no
              management or standards are created and enforced at all, reeking
              pain and suffering for anyone who has to commit code).
            </li>
            <li>
              In theory, the value of Flow is wrapped up in this idea (type
              theory) that if all values are identified with a type(s) then one
              can prove how sound a program will be (not unlike logical proofs).
              The theory is good, however the implementations details wears at
              the theoretical. And the implementation is not simply convention
              alone (i.e. a hammer can be designed poorly regardless of if you
              use it correctly).
            </li>
          </ul>

          <h3>2.4 - Flow Pros</h3>

          <ul>
            <li>
              Values (e.g. variables, parameters, object properties, expression
              outcomes, etc...) have a more explicit and obvious type. Which
              many claim can lead to fewer runtime errors and fewer regressions
              when refactoring.
            </li>
            <li>Avoid cluttering unit tests with type checking routines.</li>
            <li>
              Avoid writing type related checks in function calls and the
              corresponding error throwing boilerplate if the type checks fail.
            </li>
            <li>
              Possible that some JavaScript type coercion, resulting in runtime
              errors, can be avoided.
            </li>
            <li>
              Some degree of inline documentation for functions and classes is
              provided by using Flow syntax (e.g. what parameter is expect to a
              function, and in what form, and what value should be returned).
            </li>
          </ul>
        </div>

        <div id="chapter3" class="chapter">
          <h2>3 : Overview of thinking in Flow?</h2>

          <section class="sub">
            <p>
              This will briefly discuss how Flow fits into most development
              routines.
            </p>
          </section>

          <h3>3.1 - Developing with Flow</h3>

          <p>
            Flow is a node command line tool that can analysis your JavaScript
            files for types in near real time. Most developers have Flow
            integrated into their IDE so that as they work in their code Flow is
            always checking and reporting on Flow errors in real time without
            having to monitor or use a command line interface.
          </p>

          <p>
            The files that Flow checks can be designated file by file or one can
            configure Flow to check all files of X type in certain directories.
            Given that you can tell Flow exactly which files to check and which
            files not to check many consider Flow to be something you can
            gradually adopt.
          </p>

          <p>
            To designate the files you want Flow to monitor (assuming you have
            <a href="https://flow.org/en/docs/install/">installed</a> and are
            <a href="https://flow.org/en/docs/usage/">running</a> Flow), from
            within the files themselves, simply add the following comment to the
            top of the file:
          </p>

          <pre class="line-numbers"><code class="language-js noRun">// @flow



</code></pre>
          <p>or</p>
          <pre class="line-numbers"><code class="language-js noRun">/* @flow */



</code></pre>

          <h3>3.2 - Flow Type Inferences</h3>

          <p>
            Without adding any Flow type annotation syntax, and assuming a file
            has <code>// @flow</code> on the first line, Flow will infer types
            for all values in your file (Including imported values).
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow  

function square(n) {
  return n * n; // type error inferred because expression expects numbers not strings
}

square("2");

/* Flow command line tool or Flow running in your IDE will indicate the following errors:

4:   return n * n; // type error inferred because expression expects numbers not strings
            ^ Cannot perform arithmetic operation because string [1] is not a number.
References:
7: square("2");
          ^ [1]
4:   return n * n; // type error inferred because expression expects numbers not strings
                ^ Cannot perform arithmetic operation because string [1] is not a number.
References:
7: square("2");
          ^ [1]
*/
  </code></pre>

          <p>
            Note that without Flow annotations (i.e. inference alone), Flow will
            have too:
          </p>

          <p>
            <quote
              >"If Flow is unable to figure out what the exact type is for each
              value, Flow must figure out what every possible value is and check
              to make sure that the code around it will still work with all of
              the possible types." - Flow Docs</quote
            >
          </p>

          <p>
            Inference errors alone do not bring much value. The point of adding
            Flow to your code is so that you can annotate values with types
            (especially values like functions parameters, values returned from
            functions, Object property's, and Array values). Inferences from
            Flow is just a courtesy so you don't have to type everything, but
            Flow assumes that you are not only using Flow for inferences. Flow's
            value is tied up in using the annotating system it provides to
            explicitly track values (i.e. by using type annotations one can
            create logical proofs for all values so that it will be near
            impossible for type errors to occur).
          </p>

          <h3>3.3 - What is a Flow Type Annotation?</h3>

          <p>
            Flow essentially provides a syntax, pretty much an evolution of the
            JavaScript language, that it unfortunately calls "Types" (This can
            get confusing because it does not correlate exactly to native types
            in JavaScript). Flow type syntax/annotations are added to your
            JavaScript, which is used by Flow to lint/analysis your code in the
            context of a static type system (i.e. flow annotations layer over
            the top of JavaScript a custom sub-language syntax that is used by
            the Flow type checking system).
          </p>

          <p>
            Flow offers the following type annotations (i.e. really an entire
            type syntax, including tools and utilities, for statically typing
            values in JavaScript):
          </p>

          <p>
            <strong>Primitive Types</strong><br />
            <strong>Literal Types</strong><br />
            <strong>Mixed Types</strong><br />
            <strong>Any Types</strong><br />
            <strong>Maybe Types</strong><br />
            <strong>Function Types</strong><br />
            <strong>Object Types</strong><br />
            <strong>Array Types</strong><br />
            <strong>Tuple Types</strong><br />
            <strong>Class Types</strong><br />
            <strong>Type Aliases</strong><br />
            <strong>Opaque Type Aliases</strong><br />
            <strong>Interface Types</strong><br />
            <strong>Generic Types</strong><br />
            <strong>Union Types</strong><br />
            <strong>Intersection Types</strong><br />
            <strong>Type Casting Expressions</strong><br />
            <strong>Utility Types</strong><br />
            <strong>Module Types</strong><br />
          </p>

          <h3>3.4 - Flow Language Restrictions/Linting</h3>

          <p>
            As previously mentioned, Flow can infer types and can be told about
            types via annotations. But Flow can also restrict the language via
            an internal Flow linting system. For example it will lint/complain
            about passing unexpected arguments to a function.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow  

const myFunc = (x) => {
  return x;
}

myFunc(1,2);

/* Flow command line tool or Flow running in your IDE will indicate the following errors:

5: myFunc(1,2);
            ^ Cannot call `myFunc` because no more than 1 argument is expected by function [1].
References:
1: const myFunc = (x) => {                  ^ [1]

*/
</code></pre>

          <h3>3.5 - What can be Annotated?</h3>

          <p>
            Any value or expression in JavaScript can be annotated. If you're
            new to Flow or static types this might not help you grok exactly how
            JavaScript is annotated with Flow types. It might initially be
            helpful to think about what can be annotated (or inferred) in terms
            of the following simplistic expressions that result in JavaScript
            values:
          </p>

          <p>
            <strong>Variable's:</strong><br />
            <strong>Function Parameter's:</strong><br />
            <strong>A Function's Return Value:</strong><br />
            <strong>Object's</strong><br />
            <strong>Array's</strong><br />
            <strong>Class's</strong><br />
            <strong>Expressions</strong><br />
          </p>

          <p>
            Below each of the above typing situations are simplistically and
            briefly explored in order to initially reveal some insight into what
            can be typed (Most of the examples use very simple Flow type
            annotations e.g. primitive types):
          </p>

          <p><strong>Variable's:</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that this variable can only hold a 
// string or undefined using primitive type annotations

let myVariable: string | undefined = undefined;

</code></pre>

          <p><strong>Function Parameter's:</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that parameter a and b can only hold a 
// string using primitive type annotations

function concat(a: string, b: string){
  return a + b;
}

</code></pre>

          <p><strong>A Function's Return Value:</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that this function can only return a
// string using primitive type annotations

function concat(a, b):string {
  return a + b;
}

</code></pre>

          <p><strong>Object's</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that myObject must be an object and must have a name property 
// and the value must be a string using primitive type annotations

var myObject: {| name: string |} = { name: 'pat' };

</code></pre>

          <p><strong>Array's</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that myArray must be an array and can only contain 
// number values using primitive type annotations

let arr: Array&lt;number&gt; = [1, 2, 3];

</code></pre>

          <p><strong>Class's</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that myClassInstance must follow the types defined in TheClass

class TheClass { 
  score:number = 0
  noScoreMessage:string = 'No Score'
}

let myClassInstance: TheClass = new TheClass();

</code></pre>

          <p><strong>Expression's</strong></p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that the expression 2+2 must result in a number value

(2 + 2: number);

</code></pre>

          <div class="notes">
            <p>
              <strong>Keep In Mind:</strong>
            </p>
            <ol>
              <li>
                Anything you don't annotate will get inferred by Flow (i.e. Flow
                will deduct what the type is based on how it is used or what
                data structures get assigned).
              </li>
            </ol>
          </div>
        </div>

        <div id="chapter4" class="chapter">
          <h2>4 : Basic Flow Type Annotations:</h2>

          <section class="sub">
            <p>
              This section outlines the basic Flow type annotation syntax.
            </p>
          </section>

          <h3>4.1 - JavaScript Type Types</h3>

          <p>
            Flow offers the following annotations for the common JavaScript data
            type structures which I call type type annotations:
          </p>

          <p>
            Primitive Types<br />
            Function Types<br />
            Object Types<br />
            Array Types<br />
            Class Types<br />
          </p>

          <p><strong>Primitive Types:</strong></p>

          <p>
            A JavaScript value (e.g. variables, parameters, Object properties
            etc...) can be annotated as a primitive value using of the following
            flow type annotations:
          </p>

          <ul>
            <li><code>: boolean</code></li>
            <li><code>: number</code></li>
            <li><code>: string</code></li>
            <li><code>: null</code></li>
            <li>
              <code>: void</code> (void is used to mean <code>undefined</code>)
            </li>
          </ul>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

let opened : boolean = false;
let score : number = 0;
let middleName : string = 'leroy';
const constantNull : null = null;
const constantUndefined : void = undefined; // Note void is used for undefined

</code></pre>

          <p><strong>Function Types:</strong></p>

          <p>
            A JavaScript value (e.g. variables, parameters, Object properties
            etc...) can be annotated as a function type using one of the
            following flow type annotations:
          </p>

          <ul>
            <li><code>: () =&gt; void</code></li>
            <li>
              <code>: Function</code> (Don't use this, be aware however you
              might see its use. Instead use <code>any</code> or
              <code>(...args: Array&lt;any&gt;) =&gt; any)</code>
            </li>
          </ul>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// myFunc has to be a function that returns a string

let myFunc : (num : number) =&gt; string;

myFunc = (num) =&gt; {
return num.toString();
};

myFunc(34241312);

</code></pre>

          <p>Can also be written (But really ugly and hard to read):</p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

let myFunc : (num : number) =&gt; string = (num) =&gt; {
  return num.toString();
};

myFunc(34241312);

</code></pre>

          <p><strong>Object Types:</strong></p>

          <p>
            A JavaScript value (e.g. variables, parameters, Object properties
            etc...) can be annotated as an Object type using the following flow
            type annotations:
          </p>

          <ul>
            <li><code>: { [key: string]: any}</code> or <code>Object</code></li>
            <li><code>: {}</code></li>
          </ul>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

let myObj1:Object = {}; // uses : Object but this is going to be deprecated

myObj1.prop = 'prop';

// Should use : { [key: string]: any} instead of : Object

let myObj2:{[key:string]:string} = {}; // uses : { [key: string]: string}

myObj2.prop = 'prop';
  
</code></pre>

          <p>
            Arbitrary objects that you don't set properties on can be annotated
            like (helpful when annotating parameters):
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

const arbitraryObject = {prop:'prop'};

let myObject:{} = arbitraryObject; // uses : {}

// or as parameter

function objectToString(obj: {}) {
  return obj.toString()
}

objectToString(arbitraryObject);
    
</code></pre>

          <div class="notes">
            <p>
              <strong>Note:</strong>
            </p>
            <ol>
              <li>
                Using the <code>?</code> character you can tell the flow checker
                that an object might have a property or it might not. For
                example, <code>let myObject : {score?:number} = {}</code> tells
                Flow that this object may or may not have a score property with
                a number value.
              </li>
              <li>
                An object can have an exact property using the
                <code>|</code> character. For example,
                <code>let myObject : {|score?:number|} = {score:120}</code>
                tells Flow that this object must have a score property with a
                number value.
              </li>
            </ol>
          </div>

          <p><strong>Array Types:</strong></p>

          <p>
            A JavaScript value (e.g. variables, parameters, Object properties
            etc...) can be annotated as an Array type using the following flow
            type annotations:
          </p>

          <ul>
            <li><code>: Array&lt;any&gt;</code></li>
            <li><code>: $ReadOnlyArray&lt;any&gt;</code></li>
          </ul>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow
  
let myArray: Array&lt;number&gt; = [1, 2, 3];; 
// a shorthand is available to the above syntax
// let myArray: number[];  

// possible to have Flow make sure certain Arrays are read only
const readonlyArray: $ReadOnlyArray&lt;number&gt; = [1, 2, 3];
      
  </code></pre>

          <p><strong>Class Types:</strong></p>

          <p>
            To annotate a Class instance, where ever you create an instance of
            the class, annotate the instance with the class name (assuming
            annotations have been added to the Class definition) .
          </p>

          <ul>
            <li><code>: TheClassName</code></li>
          </ul>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// Tell Flow that myClassInstance must follow the types defined in TheClass

class TheClass { // using https://tc39.es/proposal-class-public-fields/
  score:number = 0
  noScoreMessage:string = 'No Score'
}

let myClassInstance: TheClass = new TheClass();
  
  </code></pre>

          <h3>
            4.2 - Exact Primitive Type Values (e.g.<code>
              let foo:'foo' = 'foo'</code
            >)
          </h3>

          <p>
            Flow offers the <strong>Literal Type</strong> (e.g.
            <code>const noPoints:0 = 0; </code>) so a data structure can be
            fixed to an exact primitive value or set of primitive values. The
            primtive values that can be used are <code>true</code>,
            <code>false</code>, <code>null</code>, <code>undefined</code>, any
            string (e.g. <code>'foo'</code>), or any number (e.g.
            <code>1432</code>).
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow
function getColorBasedOnMessageType(name: "success" | "warning" | "danger"):string {
switch (name) {
case "success" : return "green";
case "warning" : return "yellow";
case "danger"  : return "red";
}
}

/*
Notice how the | character was used to provide an
exact set of string values
/*

getColor("success"); 
getColor("danger");  
getColor("error");   // Error, can only be "success" | "warning" | "danger"

</code></pre>

          <h3>
            4.3 - May or May not Exist Type Values (i.e.
            <code>: ?[TYPE HERE]</code>)
          </h3>

          <p>
            Flow offers the <strong>Maybe Type</strong> (e.g.
            <code>let score: ?number</code>) that can be combined with any other
            type to signify that the type is optional and if it does not exist
            then that is ok (i.e. it is <code>null</code> or
            <code>undefined</code>).
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

function acceptsMaybeNumber(value: ?number) {
  // ...
}

acceptsMaybeNumber(42);        
acceptsMaybeNumber();          
acceptsMaybeNumber(undefined); 
acceptsMaybeNumber(null);      
acceptsMaybeNumber("42");      // Error, can only be a number, undefined, or null

</code></pre>
          <h3>4.4 - Opt out of Flow Type (i.e. <code>: any</code>)</h3>

          <p>
            Flow offers the <strong>Any Type</strong> (e.g. <code>: any</code>)
            annotation to basically opt out of using the type checker.
            Essentially by using <code>: any</code> you side step the checker
            and allow JavaScript to do its normal thing in terms of type
            coercion and error'ing.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

function add(one: any, two: any): number {
return one + two;
}

add(1, 2);     // no flow error.
add("1", "2"); // no flow error.
add({}, []);   // no flow error.

</code></pre>
          <h3>4.5 - Unknown Type (i.e. <code>: mixed</code>)</h3>

          <p>
            Flow offers the <strong>Unknown Type</strong> (i.e.
            <code>: mixed</code>) so that any data structure can be provided.
            However, if the mixed value is used then logic (e.g.
            <code>if</code> statement) has to exist that will determine its type
            or Flow will complain (as opposed to <code>:any</code> which won't
            complain about anything)
          </p>

          <p>This fails the Flow checker:</p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

function stringify(value: mixed) {
// $ExpectError
return "" + value; // Error!
}

stringify("foo");

/*
3:     return "" + value; // Error!
        ^ Cannot add empty string and `value` because mixed [1] could either behave like a string or like a number.
References:
1:   function stringify(value: mixed) {
                    ^ [1]
*/

</code></pre>

          <p>But this does not:</p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

function stringify(value: mixed) {
if (typeof value === 'string') {
return "" + value; // Works!
} else {
return "";
}
}

stringify("foo");

</code></pre>

          <h3>
            4.6 - Optional properties and parameters (i.e.
            <code>[PARAM or PROP]? :</code>)
          </h3>

          <p></p>

          <pre class="line-numbers"><code class="language-js noRun">
  // no flow error.

</code></pre>
        </div>

        <div id="chapter5" class="chapter">
          <h2>5 : Organizing Types</h2>

          <section class="sub">
            <p>
              This section outlines how to organize and separate Flow types from
              JavaScript code
            </p>
          </section>

          <h3>5.2 - Type Aliases</h3>

          <p>
            Flow annotations do not have to be written inline. It is possible
            using the Flow <code>type</code> syntax to create an aliase to flow
            annotations. This makes re-use and separation of concerns possible.
          </p>

          <p>
            For example syntax heavy inline type definitions like this function
            type (i.e. inline type noise and difficult to read):
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

let myFunc : (num : number) =&gt; string = (num) =&gt; {
  return num.toString();
};

let myOtherFunc : (num : number) =&gt; string = (num) =&gt; {
  return num.toString();
};

myFunc(34241312);
myOtherFunc(34241312);

</code></pre>

          <p>
            Can be visually simplified and made re-usable using typed aliases.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">
// @flow

// myFuncFlowAliase 
type myFuncFlowAliase = (num : number) =&gt; string;

// this function takes a number and returns a string 
let myFunc : myFuncFlowAliase = (num) =&gt; {
  return num.toString();
};

let myOtherFunc : myFuncFlowAliase = (num) =&gt; {
  return num.toString();
};

myFunc(34241312);
myOtherFunc(34241312);
    
    </code></pre>

          <p>
            Flow Type aliases can be used anywhere a type annotation can be
            used.
          </p>

          <div class="notes">
            <p>
              <strong>Note:</strong>
            </p>
            <ol>
              <li>
                In my opinion all types should be aliased, removing as much
                noise from actual JavaScript as possible. Shared types should be
                imported into modules and local types should be organized below
                module imports.
              </li>
              <li>
                In my opinion all aliases should end with the same identifier
                "FA" or "FlowAliase".
              </li>
            </ol>
          </div>

          <h3>5.2 - Importing/Exporting Type Aliases</h3>

          <p>
            In Flow, you can export type aliases, interfaces, and classes from
            one file and import them in another.
          </p>

          <pre class="line-numbers"><code class="language-js noRun">

// @flow
export default class Foo {};
export type MyObject = { /* ... */ };
export interface MyInterface { /* ... */ };

</code></pre>

          <p>Import:</p>

          <pre class="line-numbers"><code class="language-js noRun">

// @flow
import type Foo, {MyObject, MyInterface} from './exports';

</code></pre>
        </div>

        <div id="chapter6" class="chapter">
          <h2>References</h2>

          <section class="sub">
            <p>
              These external resources have been used in the creation of these
              notes.
            </p>
          </section>
          <ul>
            <li>
              <a href="https://youtu.be/Eti6_bSRgHU"
                >"Flow - Am I Your Type?" by Mark Volkmann</a
              >
            </li>
            <li>
              <a href="https://www.youtube.com/watch?v=MuC8I1JBKv0"
                >"The design of JavaScript type systems" by Dimitris
                Vardoulakis</a
              >
            </li>
            <li>
              <a href="https://youtu.be/lk8o7ym29WM"
                >Flow Typing a React Codebase - Forbes Lindesay</a
              >
            </li>
            <li>
              <a href="https://youtu.be/V1po0BT7kacs"
                >Jared Forsyth - Type Systems Will Make You a Better JavaScript
                Developer - React Conf 2017</a
              >
            </li>
            <li>
              <a
                href="https://www.freecodecamp.org/news/why-use-static-types-in-javascript-part-1-8382da1e0adb/"
                >Why use static types in JavaScript? (A 4-part primer on static
                typing with Flow)</a
              >
            </li>
            <li><a href="https://flow.org/en/docs/">Flow Docs</a></li>
            <li>
              <a href="https://www.manning.com/books/programming-with-types"
                >Programming with Types Examples in TypeScript</a
              >
            </li>
          </ul>
        </div>
      </div>
    </div>

    <script src="../js/slideout.min.js "></script>
    <script src="../js/jquery-3.3.1.slim.min.js "></script>

    <script>
      // Create slide out TOC
      var slideout = new Slideout({
        panel: document.getElementById("panel"),
        menu: document.getElementById("menu"),
        padding: 356,
        tolerance: 70
      });

      // Create TOC dynamically from content
      jQuery(".chapter").each(function(index) {
        jQuery("h2", "#chapter" + (index + 1)).each(function(i) {
          $(this).attr("id", index + 1);
          $("#toc").append(
            '<h5><a href="#' + (index + 1) + '">' + $(this).html() + "</a></h5>"
          );
        });

        jQuery("h3", "#chapter" + (index + 1)).each(function(i) {
          $(this).attr("id", index + 1 + "." + (i + 1));
          $("#toc").append(
            '<h6><a href="#' +
              (index + 1) +
              "." +
              (i + 1) +
              '">' +
              $(this).html() +
              "</a></h6>"
          );
        });
      });

      jQuery("#panel").on(
        "click",
        "a:not(.codesandboxlink a, .toolbar a)",
        function() {
          window.open($(this).attr("href"));
          return false;
        }
      );

      // create link to codesandob
      jQuery(".line-numbers:has(.language-js)")
        .not(":has(.noRun)")
        .before(
          '<div class="codesandboxlink"><a href="#">run/edit in codesandbox.io</a></div>'
        );

      // create event handler for codesandbox link
      jQuery("#panel").on("click", ".codesandboxlink a", function(e) {
        const code = $(this)
          .parent()
          .next(".code-toolbar:has(.language-js)")
          .find("code")
          .text();
        var newWindow = window.open("", "_blank");
        fetch("https://codesandbox.io/api/v1/sandboxes/define?json=1", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Accept: "application/json"
          },
          body: JSON.stringify({
            files: {
              "index.js": {
                content: code
              },
              "index.html": {
                content:
                  '<script src="./node_modules/babel-polyfill/dist/polyfill.js"><\/script><script src="https://unpkg.com/core-js-bundle@3.0.0-beta.3/index.js"><\/script><script src="index.js"><\/script>'
              },
              ".babelrc": {
                content: {
                  presets: ["env", "stage-0"]
                }
              },
              "package.json": {
                content: {
                  name: "ES2015+ Enlightenment Code Example",
                  version: "1.0.0",
                  description: "Simple Parcel/Babel Sandbox",
                  main: "index.html",
                  scripts: {
                    start: "parcel index.html --open",
                    build: "parcel build index.html"
                  },
                  dependencies: { "babel-polyfill": "6.26.0" },
                  devDependencies: {
                    "parcel-bundler": "^1.12.3",
                    "babel-preset-env": "^1.7.0",
                    "babel-preset-stage-0": "^6.24.1"
                  }
                }
              }
            }
          })
        })
          .then(x => x.json())
          .then(data => {
            newWindow.location.href =
              "https://codesandbox.io/embed/" +
              data.sandbox_id +
              "?forcerefresh=1&eslint=1&expanddevtools=1&hidenavigation=1&module=%2Findex.js";
          });
        e.preventDefault();
      });

      // toggle TOC from hamburger icon
      document
        .querySelector("#menuButton")
        .addEventListener("click", function() {
          slideout.toggle();
        });

      // toggle TOC on window resize
      window.addEventListener("resize", resizeThrottler, false);
      var resizeTimeout;
      function resizeThrottler() {
        // ignore resize events as long as an actualResizeHandler execution is in the queue
        if (!resizeTimeout) {
          resizeTimeout = setTimeout(function() {
            resizeTimeout = null;
            actualResizeHandler();

            // The actualResizeHandler will execute at a rate of 15fps
          }, 66);
        }
      }
      function actualResizeHandler() {
        if (window.innerWidth > 1036) {
          slideout.open();
        } else {
          slideout.close();
        }
      }

      // open TOC on load if window is wide enough
      window.addEventListener("load", function(event) {
        if (window.innerWidth > 1036) {
          slideout.open();
        } else {
          slideout.close();
        }
      });
    </script>
  </body>
</html>
